# Licensed under a 3-clause BSD style license - see LICENSE.rst
"""
MivotAnnotations: A utility module to build and manage MIVOT annotations.
"""
import os
import logging
import re
import requests
try:
    import xmlschema
except ImportError:
    xmlschema = None
# Use defusedxml only if already present in order to avoid a new dependency.
try:
    from defusedxml import ElementTree as etree
except ImportError:
    from xml.etree import ElementTree as etree
from astropy.io.votable.tree import VOTableFile, Resource
try:
    from astropy.io.votable.tree import MivotBlock
except ImportError:
    pass
from astropy.io.votable import parse
from astropy import version
from pyvo.utils.prototype import prototype_feature
from pyvo.mivot.utils.xml_utils import XmlUtils
from pyvo.mivot.utils.xpath_utils import XPath
from pyvo.mivot.utils.vocabulary import Att, Ele
from pyvo.mivot.utils.exceptions import MappingError, AstropyVersionException
from pyvo.mivot.utils.mivot_utils import MivotUtils
from pyvo.mivot.writer.instance import MivotInstance
from pyvo.mivot.writer.mango_instance import MangoInstance
from pyvo.mivot.version_checker import check_astropy_version

__all__ = ["MivotAnnotations"]


IVOA_STRING = "ivoa:string"
FPS_URL = "http://svo2.cab.inta-csic.es/svo/theory/fps/fpsmivot.php?PhotCalID="

@prototype_feature("MIVOT")
class MivotAnnotations:
    """
    This module provides a class to construct, validate, and insert MIVOT
    blocks into VOTable files.
    The MIVOT block, represented as an XML structure, is used for
    data model annotations in the IVOA ecosystem.

    The main features are:

    - Construct the MIVOT block step-by-step with various components.
    - Validate the MIVOT block against the MIVOT XML schema (if ``xmlschema`` is installed).
    - Embed the MIVOT block into an existing VOTable file.

    The MIVOT block is constructed as a string to maintain compatibility with the Astropy API.

    Attributes
    ----------
    suggested_space_frames: string array, class attribute
        A warning is emitted if a frame not in this list is used to build a space frame.
        This list matches https://www.ivoa.net/rdf/refframe/2022-02-22/refframe.html.
    suggested_ref_positions: string array, class attribute
        A warning is emitted if a reference position not in this list is
        used to build a space or a time frame.
    suggested_time_frames: string array, class attribute
        A warning is emitted if a frame not in this list is used to build a space frame.
        This list matches https://www.ivoa.net/rdf/timescale/2019-03-15/timescale.html.

    """

    # https://www.ivoa.net/rdf/refframe/2022-02-22/refframe.html
    suggested_space_frames = ["FK4", "FK5", "ICRS", "GALACTIC", "SUPER_GALACTIC", "ECLIPTIC"]
    suggested_ref_positions = ["BARYCENTER", "GEOCENTER", "TOPOCENTER"]
    # https://www.ivoa.net/rdf/timescale/2019-03-15/timescale.html
    suggested_time_frames = ["TAI", "TT", "TDT", "ET", "IAT", "UT1",
                        "UTC", "GMT", "GPS", "TCG", "TCB", "TBD", "LOCAL"]

    def __init__(self):
        """
        """
        # Dictionary containing models with their names as keys and URLs as values
        self._models = {}
        # str: Indicates the success status of the annotation process.s
        self._report_status = True
        # str: message associated with the report, used in the REPORT block.
        self._report_message = "Generated by pyvo.mivot.writer"
        # list(str or MivotInstance): GLOBALS blocks to be included in the MIVOT block.
        self._globals = []
        # list(str or MivotInstance): TEMPLATES blocks to be included in the MIVOT block.
        self._templates = []
        # str: An optional ID for the TEMPLATES block.
        self._templates_id = ""
        # str: list of the dmid of the INSTANCE stored in the GLOBALS
        self._dmids = []
        # str: Complete MIVOT block as a string
        self._mivot_block = ""

    @property
    def mivot_block(self):
        """
        Getter for the whole MIVOT block.

        Returns
        -------
        str
            Complete MIVOT block as a string.
        """
        return self._mivot_block

    def _get_report(self):
        """
        Generate the <REPORT> component of the MIVOT block.

        Returns
        -------
        str
            The <REPORT> block as a string, indicating the success or failure of the process.
        """
        if self._report_status:
            return f'<REPORT status="OK">{self._report_message}</REPORT>'
        else:
            return f'<REPORT status="FAILED">{self._report_message}</REPORT>'

    def _get_models(self):
        """
        Generate the <MODEL> components of the MIVOT block.

        Returns
        -------
        str
            The <MODEL> components as a formatted string.
        """
        models_block = ""
        for key, value in self._models.items():
            if value:
                models_block += f'<MODEL name="{key}" url="{value}" />\n'
            else:
                models_block += f'<MODEL name="{key}" />\n'

        return models_block

    def _get_globals(self):
        """
        Generate the <GLOBALS> component of the MIVOT block.

        Returns
        -------
        str
            The <GLOBALS> block as a formatted string.
        """
        globals_block = "<GLOBALS>\n"
        for glob in self._globals:
            globals_block += f"{glob}\n"
        globals_block += "</GLOBALS>\n"

        return globals_block

    def _get_templates(self):
        """
        Generate the <TEMPLATES> component of the MIVOT block.

        Returns
        -------
        str
            The <TEMPLATES> block as a formatted string, or an empty string if no templates are defined.
        """
        if not self._templates:
            return ""
        if not self._templates_id:
            templates_block = "<TEMPLATES>\n"
        else:
            templates_block = f'<TEMPLATES tableref="{self._templates_id}">\n'

        for templates in self._templates:
            templates_block += f"{templates}\n"
        templates_block += "</TEMPLATES>\n"
        return templates_block

    def build_mivot_block(self, *, templates_id=None, no_schema_check=False):
        """
        Build a complete MIVOT block from the declared components and validates it
        against the MIVOT XML schema.

        Parameters
        ----------
        templates_id : str, optional
            The ID to associate with the <TEMPLATES> block. Defaults to None.
        no_schema_check : boolean, optional
            Skip the XSD validation if True (use to make test working in local mode).

        Raises
        ------
        Any exceptions raised during XML validation are not caught and must
        be handled by the caller.
        """
        if templates_id:
            self._templates_id = templates_id
        self._mivot_block = '<VODML xmlns="http://www.ivoa.net/xml/mivot">\n'
        self._mivot_block += self._get_report()
        self._mivot_block += "\n"
        self._mivot_block += self._get_models()
        self._mivot_block += "\n"
        self._mivot_block += self._get_globals()
        self._mivot_block += "\n"
        self._mivot_block += self._get_templates()
        self._mivot_block += "\n"
        self._mivot_block += "</VODML>\n"
        self._mivot_block = self.mivot_block.replace("\n\n", "\n")
        self._mivot_block = XmlUtils.pretty_string(self._mivot_block)
        if not no_schema_check:
            self.check_xml()

    def add_templates(self, templates_instance):
        """
        Add an <INSTANCE> element to the <TEMPLATES> block.

        Parameters
        ----------
        templates_instance : str or MivotInstance
            The <INSTANCE> element to be added.

        Raises
        ------
        MappingError
            If ``templates_instance`` is neither a string nor an instance of `MivotInstance`.
        """
        if isinstance(templates_instance, MivotInstance):
            self._templates.append(templates_instance.xml_string())
            if templates_instance.dmid is not None:
                self._dmids.append(templates_instance.dmid)
        elif isinstance(templates_instance, str):
            self._templates.append(templates_instance)
        else:
            raise MappingError(
                "Instance added to templates must be a string or MivotInstance."
            )

    def add_globals(self, globals_instance):
        """
        Add an <INSTANCE> block to the <GLOBALS> block.

        Parameters
        ----------
        globals_instance : str or MivotInstance
            The <INSTANCE> block to be added.

        Raises
        ------
        MappingError
            If ``globals_instance`` is neither a string nor an instance of `MivotInstance`.
        """
        if isinstance(globals_instance, MivotInstance):
            self._globals.append(globals_instance.xml_string())
            if globals_instance.dmid is not None:
                self._dmids.append(globals_instance.dmid)
        elif isinstance(globals_instance, str):
            self._globals.append(globals_instance)
        else:
            raise MappingError(
                "Instance added to globals must be a string or MivotInstance."
            )

    def add_model(self, model_name, *, vodml_url=None):
        """
        Add a <MODEL> element to the MIVOT block.

        Parameters
        ----------
        model_name : str
            The short name of the model.
        vodml_url : str, optional
            The URL of the VO-DML file associated with the model.
        """
        self._models[model_name] = vodml_url

    def add_simple_space_frame(self, ref_frame="ICRS", *, ref_position="BARYCENTER", equinox=None):
        """
        Adds a SpaceSys instance to the GLOBALS block as defined in the Coordinates
        data model V1.0 (https://ivoa.net/documents/Coords/20221004/index.html).

        Notes:

        - This function implements only the most commonly used features. Custom reference positions
          for TOPOCENTER frames are not supported. However, methods for implementing the missing
          features can be derived from this code.
        - A warning is emitted if either ``ref_frame`` or ``ref_position`` have unexpected values.
        - No error is raised if the parameter values are inconsistent.
        - The ``dmid`` of the time rame is built from ``ref_frame``, ``ref_position`` and ``equinox``.

        Parameters
        ----------
        ref_frame : str, optional, default "ICRS"
            The reference frame for the space frame.

        ref_position : str, optional, default "BARYCENTER"
            The reference position for the space frame.

        equinox : str, optional, default None
            The equinox for the reference frame, if applicable.

        return
        ------
        str: The actual dmid of the time frame INSTANCE
        """
        # buikd the dmid
        dmid = f"_spaceframe_{ref_frame}"
        if equinox:
            dmid += f"_{equinox}"
        if ref_position:
            dmid += f"_{ref_position}"

        # skip if the same dmid is already recorded
        if dmid in self._dmids:
            logging.warning("An instance with dmid=%s has already been stored in GLOBALS: skip",
                            dmid)
            return dmid
        self._dmids.append(dmid)
        # add (or overwrite) used models
        self.add_model("ivoa",
                       vodml_url="https://www.ivoa.net/xml/VODML/IVOA-v1.vo-dml.xml")
        self.add_model("coords",
                       vodml_url="https://www.ivoa.net/xml/STC/20200908/Coords-v1.0.vo-dml.xml")

        # check whether ref_frame and ref_position are set with appropriate values
        if ref_frame not in MivotAnnotations.suggested_space_frames:
            logging.warning("Ref frame %s is not in %s, make sure there is no typo",
                            ref_frame,
                            MivotAnnotations.suggested_space_frames)
        if ref_position not in MivotAnnotations.suggested_ref_positions:
            logging.warning("Ref position %s is not in %s, make sure there is no typo",
                            ref_position,
                            MivotAnnotations.suggested_ref_positions)

        # Build the SpaceSys instance component by component
        space_system_instance = MivotInstance(dmtype="coords:SpaceSys",
                                              dmid=dmid)
        # let's start with the space frame
        space_frame_instance = MivotInstance(dmtype="coords:SpaceFrame",
                                             dmrole="coords:PhysicalCoordSys.frame")
        space_frame_instance.add_attribute(dmtype=IVOA_STRING,
                                           dmrole="coords:SpaceFrame.spaceRefFrame",
                                           value=ref_frame)
        if equinox is not None:
            space_frame_instance.add_attribute(dmtype="coords:Epoch",
                                               dmrole="coords:SpaceFrame.equinox",
                                               value=equinox)
        # then let's build the reference position
        ref_position_instance = MivotInstance(dmtype="coords:StdRefLocation",
                                              dmrole="coords:SpaceFrame.refPosition")
        ref_position_instance.add_attribute(dmtype=IVOA_STRING,
                                            dmrole="coords:StdRefLocation.position",
                                            value=ref_position)
        # and pack everything
        space_frame_instance.add_instance(ref_position_instance)
        space_system_instance.add_instance(space_frame_instance)
        # add the SpaceSys instance to the GLOBALS block
        self.add_globals(space_system_instance)

        return dmid

    def add_simple_time_frame(self, ref_frame="TCB", *, ref_position="BARYCENTER"):
        """
        Adds a TimeSys instance to the GLOBALS block as defined in the Coordinates
        data model V1.0 (https://ivoa.net/documents/Coords/20221004/index.html).

        Notes:

        - This function implements only the most commonly used features. Custom reference directions
          are not supported. However, methods for implementing missing features can be derived from
          this code.
        - A warning is emitted if either ``ref_frame`` or ``ref_position`` have unexpected values.
        - No error is raised if the parameter values are inconsistent.
        - The ``dmid`` of the time rame is built from ``ref_frame`` and ``ref_position``.

        Parameters
        ----------
        ref_frame : str, optional, default "TCB"
            The reference frame for the time frame.

        ref_position : str, optional, default "BARYCENTER"
            The reference position for the time frame.

        return
        ------
        str: The actual dmid of the time frame INSTANCE
        """
        # buikd the dmid
        dmid = f"_timeframe_{ref_frame}"
        if ref_position:
            dmid += f"_{ref_position}"
        dmid = MivotUtils.format_dmid(dmid)
        # skip if the same dmid is already recorded
        if dmid in self._dmids:
            logging.warning("An instance with dmid=%s has already been stored in GLOBALS: skip", dmid)
            return dmid
        self._dmids.append(dmid)
        # add (or overwrite) used models
        self.add_model("ivoa",
                       vodml_url="https://www.ivoa.net/xml/VODML/IVOA-v1.vo-dml.xml")
        self.add_model("coords",
                       vodml_url="https://www.ivoa.net/xml/STC/20200908/Coords-v1.0.vo-dml.xml")
        # check whether ref_frame and ref_position are set with appropriate values
        if ref_frame not in MivotAnnotations.suggested_time_frames:
            logging.warning("Ref frame %s is not in %s, make sure there is no typo",
                            ref_frame,
                            MivotAnnotations.suggested_time_frames)
        if ref_position not in MivotAnnotations.suggested_ref_positions:
            logging.warning("Ref position %s is not in %s, make sure there is no typo",
                            ref_position,
                            MivotAnnotations.suggested_ref_positions)
        # Build the TimeSys instance component by component
        time_sys_instance = MivotInstance(dmtype="coords:TimeSys",
                                          dmid=dmid)
        # Let's start with the time frame
        time_frame_instance = MivotInstance(dmtype="coords:TimeFrame",
                                            dmrole="coords:PhysicalCoordSys.frame")
        time_frame_instance.add_attribute(dmtype=IVOA_STRING,
                                          dmrole="coords:TimeFrame.timescale",
                                          value=ref_frame)
        # Then let's build the reference position
        ref_position_instance = MivotInstance(dmtype="coords:StdRefLocation",
                                              dmrole="coords:TimeFrame.refPosition")
        ref_position_instance.add_attribute(dmtype=IVOA_STRING,
                                            dmrole="coords:StdRefLocation.position",
                                            value=ref_position)
        # pack everything
        time_frame_instance.add_instance(ref_position_instance)
        time_sys_instance.add_instance(time_frame_instance)
        # add the TimeSys instance to the GLOBALS block
        self.add_globals(time_sys_instance)

        return dmid

    def add_photcal(self, filter_name):
        """
        Add to the GLOBALS the requested photometric calibration as defined in PhotDM1.1.

        The MIVOT serialization is provided by the SVO Filter Profile Service
        (https://ui.adsabs.harvard.edu/abs/2020sea..confE.182R/abstract)

        It is returned as one block containing the whole PhotCal instance.
        The Filter instance is extracted from the PhotCal one where it is replaced by a REFERENCE.
        This make the filter accessible as a GLOBALS for objects that would need it.

        - The dmid of the PhotCal is ``_photcal_DMID`` where DMID is the formatted version of ``dmid``
          (see `MivotUtils.format_dmid`).
        - The dmid of the PhotFilter is ``_photfilter_DMID`` where DMID is the formatted version of ``dmid``.

        Parameters
        ----------
        filter_name: str
            FPS identifier (SVO Photcal ID) of the request filter
        return
        ------
        str: The actual dmid of the PhotCal INSTANCE or None
        """
        response = requests.get(FPS_URL + filter_name)
        if (http_code := response.status_code) != 200:
            logging.error("FPS service error: %s", http_code)
            return None
        # get the MIVOT serialization of the requested Photcal (as a string)
        # FPS returns bytes but that might change
        fps_reponse = response.content
        try:
            fps_reponse = fps_reponse.decode('utf-8')
        except (UnicodeDecodeError, AttributeError):
            pass

        # basic parsing of the response to check if an error has been returned
        if "<INFO name=\"QUERY_STATUS\" value=\"ERROR\">" in fps_reponse:
            logging.error("FPS service error: %s",
                          re.search(r'<DESCRIPTION>(.*)</DESCRIPTION>', fps_reponse).group(1))
            return None

        # set the identifier that will be used for both PhotCal and PhotFilter
        cal_id = MivotUtils.format_dmid(filter_name)
        # skip if the same dmid is already recorded
        if cal_id in self._dmids:
            logging.warning("An instance with dmid=%s has already been stored in GLOBALS: skip", cal_id)
            return cal_id
        self._dmids.append(cal_id)

        photcal_id = f"_photcal_{cal_id}"
        filter_id = f"_photfilter_{cal_id}"
        logging.info("%s PhotCal can be referred with dmref='%s'", cal_id)
        # parse the PhotCal and extract the PhotFilter node
        photcal_block = etree.fromstring(fps_reponse)
        filter_block = XPath.x_path_contains(
                                photcal_block,
                                ".//" + Ele.INSTANCE,
                                Att.dmtype,
                                "Phot:photometryFilter"
                                )[0]
        # Tune the Photcal to be placed as a GLOBALS child (no role but an id)
        # and remove the PhotFilter node which will be shifted at the GLOBALS level
        del photcal_block.attrib["dmrole"]
        photcal_block.set("dmid", photcal_id)
        photcal_block.remove(filter_block)

        # Tune the PhotFilter to be placed as GLOBALS child (no role but an id)
        filter_role = filter_block.get("dmrole")
        del filter_block.attrib["dmrole"]
        filter_block.set("dmid", filter_id)

        # Append a REFERENCE on the PhotFilter node to the PhotCal block
        reference = etree.Element("REFERENCE")
        reference.set("dmrole", filter_role)
        reference.set("dmref", filter_id)
        photcal_block.append(reference)

        self.add_model("ivoa",
                       vodml_url="https://www.ivoa.net/xml/VODML/IVOA-v1.vo-dml.xml")
        self.add_model("Phot",
                       vodml_url="https://ivoa.net/xml/VODML/Phot-v1.vodml.xml")

        self.add_globals(XmlUtils.pretty_string(photcal_block, lshift="    "))
        self.add_globals(XmlUtils.pretty_string(filter_block, lshift="    "))

        return photcal_id

    def add_mango_epoch_position(self, table, *, space_frame={}, time_frame={}, sky_position={}, correlations={}, errors={}):
        space_frame_id = self.add_simple_space_frame(**space_frame)
        time_frame_id = self.add_simple_time_frame(**time_frame)
        self.add_model("mango",
                       vodml_url="https://raw.githubusercontent.com/lmichel/MANGO/refs/heads/draft-0.1/vo-dml/desc.mango.vo-dml.xml")
        mango_instance = MangoInstance(table)
        ep_instance = mango_instance.get_epoch_position(space_frame_id, time_frame_id, sky_position, correlations, errors)
        self.add_templates(ep_instance)

    def add_mango_magnitude(self, table, filter_name, mag={}):
        filter_id = self.add_photcal(filter_name)
        mango_instance = MangoInstance(table)
        print(filter_id)
        print(mag)
        mag_instance = mango_instance.get_brightness(filter_id, mag)
        self.add_templates(mag_instance)

    def set_report(self, status, message):
        """
        Set the <REPORT> element of the MIVOT block.

        Parameters
        ----------
        status : bool
            The status of the annotation process. True for success, False for failure.
        message : str
            The message associated with the REPORT.

        Notes
        -----
        If ``status`` is False, all components of the MIVOT block except MODEL and REPORT
        are cleared.
        """
        self._report_status = status
        self._report_message = message
        if not status:
            self._globals = []
            self._templates = []

    def check_xml(self):
        """
        Validate the MIVOT block against the MIVOT XML schema v1.0.

        Raises
        ------
        MappingError
            If the validation fails.

        Notes
        -----
        The schema (mivot 1.0) is loaded from a local file to avoid dependency on a remote service.
        """
        # put here just to improve the test coverage
        root = etree.fromstring(self._mivot_block)
        mivot_block = XmlUtils.pretty_string(root, clean_namespace=False)
        if not xmlschema:
            logging.error(
                "XML validation skipped: no XML schema found. "
                + "Please install it (e.g., pip install xmlschema)."
            )
            return

        schema = xmlschema.XMLSchema11(os.path.dirname(__file__) + "/mivot-v1.xsd")

        try:
            schema.validate(mivot_block)
        except Exception as excep:
            raise MappingError(f"Validation failed: {excep}") from excep

    def insert_into_votable(self, votable_file, override=False):
        """
        Insert the MIVOT block into a VOTable.

        Parameters
        ----------
        votable_file : str or VOTableFile
            The VOTable to be annotated, either as a file path or a ``VOTableFile`` instance.
        override : bool
            If True, overrides any existing annotations in the VOTable.

        Raises
        ------
        MappingError
            If a mapping block already exists and ``override`` is False.
        """
        if not check_astropy_version():
            raise AstropyVersionException(f"Astropy version {version.version} "
                                          f"is below the required version 6.0 for the use of MIVOT.")
        if isinstance(votable_file, str):
            votable = parse(votable_file)
        elif isinstance(votable_file, VOTableFile):
            votable = votable_file
        else:
            raise MappingError(
                "votable_file must be a file path string or a VOTableFile instance."
            )

        for resource in votable.resources:
            if resource.type == "results":
                for subresource in resource.resources:
                    if subresource.type == "meta":
                        if not override:
                            raise MappingError(
                                "A type='meta' resource already exists in the first 'result' resource."
                            )
                        else:
                            logging.info("Overriding existing type='meta' resource.")
                        break
                mivot_resource = Resource()
                mivot_resource.type = "meta"
                mivot_resource.mivot_block = MivotBlock(self._mivot_block)
                resource.resources.append(mivot_resource)
