# Licensed under a 3-clause BSD style license - see LICENSE.rst
"""
MivotAnnotations implements the basic functions to build MIVOT annotations.
- Add various elements to the MIVOT block
- validate it against the MIVOT XML schema (local copy) if the package xml_schema is installed
- insert the MIVOT block in a VOTable

The MIVOT block is built as a string in order to be compliant with Astropy API.
The code below shows a typical use of MivotAnnotations:

    .. code-block:: python

    mb =  MivotAnnotations()
    mb.build_mivot_block()
    
    mb.add_globals("<INSTANCE dmtype='model:type'></INSTANCE>")
    mb.add_templates("<INSTANCE dmtype='model:type.a'></INSTANCE>")
    mb.add_templates("<INSTANCE dmtype='model:type.b'></INSTANCE>")
    mb.add_model("model", "http://model.com")
    mb.add_model("model2", None)
    mb.set_report(True, "unit tests")
    mb.build_mivot_block(templates_id="azerty")
    
    votable =  parse(votable_path)
    mb.insert_into_votable(votable)
    mv = MivotViewer(votable)
    print(mv.dm_instance)

This module does not check if the MIVOT block is consistent with the declared models 
or if the references to table columns can be resolved either.

This latest point can be verified with he MivotViewer

    .. code-block:: python

    votable =  parse(votable_path)
    mb.insert_into_votable(votable)
    mv = MivotViewer(votable)
    print(mv.dm_instance)
    
See `tests/test_mivot_writer.py`to get different examples of the API usage.`
"""
import os
import logging
try:
    import xmlschema
except ImportError:
    xmlschema = None
# Use defusedxml only if already present in order to avoid a new depency.
try:
    from defusedxml import ElementTree as etree
except ImportError:
    from xml.etree import ElementTree as etree
from astropy.io.votable.tree import VOTableFile, Resource, MivotBlock
from astropy.io.votable import parse
from pyvo.utils.prototype import prototype_feature
from pyvo.mivot.utils.xml_utils import XmlUtils
from pyvo.mivot.writer.instance import MivotInstance

@prototype_feature('MIVOT')
class MivotAnnotations:    
    """
    API for building annotations step by step.
    """
    def __init__(self):
        """
        Constructor of the MivotViewer class: no logic inside
        """
        self._models = {}
        self._report_status = True
        self._report_message = "Generated by pyvo.mivot.writer"
        self._globals = []
        self._templates = []
        self._templates_id = ""        
        self._mivot_block = ""
    
    @property
    def mivot_block(self):
        """
        mivot_block getter

        Returns
        -------
        str
            the MIVOT block as a string
        """
        return self._mivot_block
    
    def _get_report(self):
        """
        Get the REPORT component of the MIVOT block

        Returns
        -------
        str
            the REPORT block as a string
        """
        if self._report_status is True:
            return f'<REPORT status="OK">{self._report_message}</REPORT>'
        else:
            return f'<REPORT status="FAILED">{self._report_message}</REPORT>'
        
    def _get_models(self):
        """
        Get the MODEL components of the MIVOT block

        Returns
        -------
        str
            the MODEL components block as a string
        """
        models_block = ""
        for key, value in self._models.items():
            if value:
                models_block += f'<MODEL name="{key}" url="{value}" />\n'
            else:
                models_block += f'<MODEL name="{key}" />\n'

        return models_block

    def _get_globals(self):      
        """
        Get the GLOBALS component of the MIVOT block

        Returns
        -------
        str
            the GLOBALS block as a string
        """
        globals_block = "<GLOBALS>\n"
        for globals in self._globals:
            globals_block += f"{globals}\n"
        globals_block += "</GLOBALS>\n"

        return globals_block
    
    def _get_templates(self):  
        """
        Get the TEMPLATES component of the MIVOT block

        Returns
        -------
        str
            the TEMPLATES block as a string or an empty string if no templates
        """
        # no TEMPLATES  blocks if no mapped object
        if not self._templates:
            return ""
        if not self._templates_id:
            templates_block = f'<TEMPLATES>\n'
        else:
            templates_block = f'<TEMPLATES tableref="{self._templates_id}">\n'
            
        for templates in self._templates:
            templates_block += f"{templates}\n"
        templates_block += "</TEMPLATES>\n"
        return templates_block
    
    def build_mivot_block(self, templates_id=None):
        """
        Buikd a complete MIVOT block from the declared components  and vaiidate the result 
        against the MIVO XML schema/
        
        Raises
        ------
        Exceptions possibly raised by the validator are not trapped and must be processed by the caller
        """
        if templates_id:
            self._templates_id = templates_id
        self._mivot_block = '<VODML xmlns="http://www.ivoa.net/xml/mivot">\n'
        self._mivot_block += self._get_report()
        self._mivot_block += '\n'
        self._mivot_block += self._get_models()
        self._mivot_block += '\n'
        self._mivot_block += self._get_globals()
        self._mivot_block += '\n'
        self._mivot_block += self._get_templates()
        self._mivot_block += '\n'
        self._mivot_block += '</VODML>\n'
        self._mivot_block = self.mivot_block.replace("\n\n", "\n")
        self.check_xml()

    def add_templates(self, templates_instance):
        """
        Add an <INSTANCE> block to the <TEMPLATES> block. 
        The templates_instance content is not checked at this level. 

        Parameters
        ----------
        templates_instance : string or MivotInstance
            <INTANCE> block to be added

        Raises
        ------
        Raises an MappingException if the globals_instance is not str or MivotInstance either.
        
        """
        if type(templates_instance) == MivotInstance:   
            self._templates.append(templates_instance.xml_string())
        elif type(templates_instance) == str:
            self._templates.append(templates_instance)
        else:
            raise MappingException("Instance added to templates must be a string or  MivotInstance")

    def add_globals(self, globals_instance):
        """
        Add an <INSTANCE> block to the <GLOBALS> block. 
        The globals_instance content is not checked at this level. 

        Parameters
        ----------
        globals_instance : string or MivotInstance
            <INSTANCE> block to be added

        Raises
        ------
        Raises an MappingException if the globals_instance is not str or MivotInstance either.
        """
        if type(globals_instance) == MivotInstance:   
            self._globals.append(globals_instance.xml_string())
        elif type(globals_instance) == str:
            self._globals.append(globals_instance)
        else:
            raise MappingException("Instance added to globals must be a string or  MivotInstance")
    
    def add_model(self, model_name, model_url):
        """
        Add a MODEL element:
        
        Parameters
        ----------
        model_name : string
           model short name
        model_url: string
           URL of the VO-DML file
        """
        self._models[model_name] = model_url
    
    def set_report(self, status, message):
        """
        Set the REPORT element. If the REPOPRT is set to failed, 
        all component of the MIVOT block are deleted except MODEL and REPORT
        Parameters
        ----------
        status : boolean
            status of the annotation process
        message: string
            REPORT message
        """
        self._report_status = status
        self._report_message = message
        if status is False:
            self._globals = []
            self._templates = []
    
    def check_xml(self):
        """
        Validate the mapping block against the MIVOT XML schema v1.0.
        The schema is copied locally to avoid a dependency with a remote service

        Raises
        ------
        MappingException if the validation fails
        """
        if not xmlschema:
            logging.error("XML validation skipped: " +
                          "no XML schema found, " +
                          "please install it (e.g. pip install xmlschema)")
            return
            
        schema = xmlschema.XMLSchema11(os.path.dirname(__file__) + "/mivot-v1.xsd")
        root = etree.fromstring(self._mivot_block)
        mivot_block = XmlUtils.pretty_string(root, clean_ns=False)

        try:
            schema.validate(mivot_block)
        except Exception as excep:
            raise MappingException(f"validation failed {excep}") from excep

    def insert_into_votable(self, votable_file,  template_id=None, override=False):
        """
        Parameters
        ----------
        votable_file : path like string or a VOTableFile
            VOTable to be annotated
        template_id: string
            ID of the TABLE to be mapped, ignored if None
        override : boolean
            override former annotations if Tue
            
        Raises
        -----
        MappingException if a mapping block is already here and override is False
        """
        if type(votable_file) == str:            
            votable = parse(votable_file)
        elif type(votable_file) == VOTableFile:
            votable = votable_file
        else:
            raise MappingException("votable_file must be either a path like string or a VOTableFile")

        for resource in votable.resources:
            if resource.type == "results":
                for subresource in resource.resources:
                    if sub_resource.type == "meta":
                        if override is False:
                            raise MappingException(
                                "There is already a type='meta' in the first result resource")
                        else:
                            logging.info(
                                "There is already a type='meta' in the first result resource that will be overridden")
                        break
                mivot_resource = Resource() 
                mivot_resource.type = "meta"
                mivot_resource.mivot_block =  MivotBlock(self._mivot_block)
                resource.resources.append(mivot_resource)
    
